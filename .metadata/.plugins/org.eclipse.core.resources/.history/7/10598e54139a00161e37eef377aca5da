#include "keyboard.h"

static int hook_id_kbd;
int HAS_2_BYTE = 0;
unsigned short status=0;

int keyboard_subscribe_int()
{
	hook_id_kbd = IRQ_KBD;
	if (sys_irqsetpolicy(IRQ_KBD, IRQ_REENABLE|IRQ_EXCLUSIVE, &hook_id_kbd) != OK)
	{
		printf("Sys_irqserpolicy failed!\n");
		return -1;
	}
	else
	{
		return IRQ_KBD;
	}
}

int keyboard_unsubscribe_int()
{
	if(sys_irqrmpolicy(&hook_id_kbd) ==OK)
	{
		if(sys_irqdisable(&hook_id_kbd)== OK)
		{
			return 0;
		}
		else
		{
			printf("Sys_irqdisable failed!\n");
			return -1;
		}
	}
	else
	{
		printf("Sys_irqrmpolicy failed!\n");
		return -1;
	}
}

int keyboard_scan_c(){
	unsigned long scan_code;
	unsigned long st;

	unsigned int c = 0;


	if(sys_inb(OUT_BUF, &scan_code) != OK)
	{
		printf("sys_inb(OUTPUT_BUFFER_FULL, scancode) function failed! \n");
		return 1;
	}

	if(scan_code == TWO_BYTE_SCANCODE){
		HAS_2_BYTE = 1;
		return 0;
	}

	if(HAS_2_BYTE == 1)
	{
		scan_code = (scan_code | (TWO_BYTE_SCANCODE << 8));
		HAS_2_BYTE = 0;
	}

	if(scan_code & BREAK_CODE_BIT){

		printf("Breakcode: 0x%X \n", scan_code);
		if(scan_code == ESC)
		{
			return -1;
		}
	}
	else
	{
		printf("Makecode: 0x%X \n", scan_code);
	}

	return 0;


}

int keyboard_write_cmd(unsigned long command)
{
	unsigned long stat;
	unsigned int i=0;

	while (i < NUMBER_TRIES)
	{
		if(sys_inb(STAT_REG, &stat)!=OK)
		{
			printf("sys_inb function failed!\n");
			return -1;
		}

		if ((stat & INPUT_BUFFER_FULL) == 0)
		{
			if(sys_outb(KBD_CMD_REG, command)!=OK)
			{
				printf("sys_outb function failed! \n");
				return -1;
			}
			return 0;
		}
		tickdelay(micros_to_ticks(DELAY_US));
		i++;
	}

}

unsigned long keyboard_read_resp(unsigned long data)
{
	unsigned long stat;
	unsigned int i=0;

	while (i < NUMBER_TRIES)
	{
		if(sys_inb(STAT_REG, &stat)!=OK)
		{
			printf("sys_inb function failed!\n");
			return -1;
		}
		if (stat & OUTPUT_BUFFER_FULL)
		{
			if(sys_inb(OUT_BUF, &data)!=OK)
			{
				printf("sys_inb function failed!\n");
				return -1;
			}
			if ((stat &(PARITY|TIMEOUT)) == 0)
				return data;
			else
				return -1;
		}
		tickdelay(micros_to_ticks(DELAY_US));
		i++;
	}


}

int keyboard_leds(unsigned int led)
{
	unsigned int i=0;
	unsigned long data = 0;

	do {
		if (keyboard_write_cmd(KBD_SWITCH_LED) == -1)
		{
			printf("keyboard_write_cmd function failed\n");
			return 1;
		}

		if (keyboard_read_resp(data) == -1) {
			printf("keyboard_read_resp function failed\n");
			return 1;
		}

		i++;
	} while ((data == ERROR || data == RESEND) && i < NUMBER_TRIES);

	if (i < NUMBER_TRIES) {
		i = 0;
	} else {
		printf("Way too many tries(1)! \n");
		return 1;
	}

	status= status^BIT(led);
	printf("%d\n",led);

	do {
		if (keyboard_write_cmd(status) == -1)
		{
			printf("keyboard_write_cmd function failed\n");
			return 1;
		}

		if (keyboard_read_resp(data) == -1)
		{
			printf("keyboard_read_resp function failed\n");
			return 1;
		}

		i++;

	} while ((data == ERROR || data == RESEND) && i < NUMBER_TRIES);

	if (i >= NUMBER_TRIES)
	{
		printf("Way too many tries(2)! \n");
		return 1;
	}

	return 0;
}
